#echo "=> Loading `pwd`/aliases"

# Handle the fact that this file will be used with multiple OSs
platform=`uname`
if [[ $platform == 'Linux' ]]; then
  alias a='ls -lrth --color'
  alias ls='ls --color=auto'
  alias get='sudo apt-get install'
  export EDITOR=$(which vim)
elif [[ $platform == 'Darwin' ]]; then
  alias a='ls -lrthG'
  alias ls='ls -G'  # OS-X SPECIFIC - the -G command in OS-X is for colors, in Linux it's no groups
  alias show_invisibles='defaults write com.Apple.Finder AppleShowAllFiles true'
  alias hide_invisibles='defaults write com.Apple.Finder AppleShowAllFiles false'

  if [ -d /Applications/MacVim.app/ ]; then
    # use MacVim over built-in Mac OS version
    export PATH="/Applications/MacVim.app/Contents/MacOS:$PATH"
    alias e='mvim .'
    alias vi='mvim'
    export EDITOR='mvim -f --nomru'
    alias vimdiff="mvim -d"
  fi
  
  # Change to current Finder directory
  cd "`osascript -e 'tell application "Finder" to if window 1 exists then if target of window 1 as string is not ":" then get POSIX path of (target of window 1 as alias)'`"
fi

# directory listing & navigation
alias l="ls -lAh"
alias ll='ls -hl'
alias la='ls -a'
alias lla='ls -lah'

alias ..='cd ..'
alias ...='cd .. ; cd ..'
alias q='exit'

# git
alias gl='git pull'
alias gp='git push'
alias gd='git diff'
alias ga='git add'
alias gc='git commit'
alias gca='git commit -a'
alias gcm='git commit -m'
alias gcam='git commit -am'
alias gco='git checkout'
alias gb='git branch'
alias g='git status -sb'
alias gs='git status'
alias grm="git status | grep deleted | awk '{print \$3}' | xargs git rm"
alias changelog='git log `git log -1 --format=%H -- CHANGELOG*`..; cat CHANGELOG*'
alias dt='git difftool'
alias dtc='git difftool --cached'
alias dth='git difftool HEAD'
alias gg='git lg'
alias today='git lg --since="1 day ago"'

# Subversion & diff 
export SV_USER='swinter'  # Change this to your username that you normally use on subversion (only if it is different from your logged in name)
export SVN_EDITOR='${EDITOR}'

alias sv='svn --username ${SV_USER}'
alias svimport='sv import'
alias svcheckout='sv checkout'
alias svstatus='sv status'
alias svupdate='sv update'
alias svstatusonserver='sv status --show-updates' # Show status here and on the server
alias svcommit='sv commit'
alias svadd='svn add'
alias svaddall='svn status | grep "^\?" | awk "{print \$2}" | xargs svn add'
alias svdelete='sv delete'
alias svhelp='svn help' 
alias svblame='sv blame'
alias svdiff='sv diff'

function svgetinfo (){
  sv info $@
  sv log $@
}

# ruby
alias irb='irb --readline -r irb/completion'

# RVM
alias gh='rvm use 1.9.2@github'
alias r2='rvm use 1.8.7@rails2'
alias r3='rvm use 1.9.2@rails3'
alias tra='rvm use 1.9.2@traction'
alias system='rvm use system'

# rails
alias sc='script/console'
alias ss='script/server'
alias sg='script/generate'
alias a='autotest -rails'
alias tlog='tail -f log/development.log'
alias scaffold='script/generate nifty_scaffold'
alias migrate='rake db:migrate db:test:clone'
alias rst='touch tmp/restart.txt'

alias rdm="rake db:migrate"
alias rdtp="rake db:test:prepare"
alias rc='rails console'
alias ss='ruby script/server -p 3001 --debugger'
alias rs='rails server -p 3001'
alias rsa='rake spec:all'
alias sc='script/console'
alias s='screen -dr rails'

# bundler 
alias bi='bundle install'

# capistrano
alias get_db='cap production db:download && rake db:backup:load'
alias get_db_staging='cap staging db:download && rake db:backup:load SOURCE_ENV=staging'

# misc
alias retag='ctags -R --exclude=.svn --exclude=.git --exclude=log *'
alias so='source ~/.dotfiles/zsh/aliases'
alias i='screen -rd irc'
alias f='find . -iname'
alias ducks='du -cksh * | sort -rn|head -11' # Lists folders and files sizes in the current folder
alias m='more'
alias df='df -h'
alias lm='!! | more'

alias py='python'
alias sha1="openssl sha1"
alias lock="open /System/Library/Frameworks/ScreenSaver.framework/Versions/A/Resources/ScreenSaverEngine.app"

alias aliases='vim ~/src/dotfiles/zsh/aliases'
alias d='cd ~/src/dotfiles'

alias showdirs="cat ~/.dirs | ruby -e \"puts STDIN.read.split.map{|x| x.gsub(/^(.+)=.+$/, '\1')}.join(', ')\""

# commands starting with % for pasting from web
alias %=' '

# subversion recursive update
alias update_recursive="~/bin/update_recursive.rb"
alias update_all="cd ~/Documents/Clients/; update_recursive;"

# Flush DNS cache
alias flushdns="dscacheutil -flushcache"

#Directory save & recall with save and show

if [ ! -f ~/.dirs ]; then  # if doesn't exist, create it
  touch ~/.dirs
fi

alias show='cat ~/.dirs'
alias showdirs="cat ~/.dirs | ruby -e \"puts STDIN.read.split(10.chr).sort.map{|x| x.gsub(/^(.+)=.+$/, '\\1')}.join(', ')\""
save (){
  local usage
  usage="Usage: save shortcut_name"
  if [ $# -lt 1 ]; then
    echo "$usage"
    return 1
  fi
  if [ $# -gt 1 ]; then
    echo "Too many arguments!"
    echo "$usage"
    return 1
  fi
  if [ -z $(echo $@ | grep --color=never "^[a-zA-Z]\w*$") ]; then
    echo "Bad argument! $@ is not a valid alias!"
    return 1
  fi
  if [ $(cat ~/.dirs | grep --color=never "^$@=" | wc -l) -gt 0 ]; then
    echo -n "That alias is already set to: "
    echo $(cat ~/.dirs | awk "/^$@=/" | sed "s/^$@=//" | tail -1)
    read -p "Do you want to overwrite it? (y/n) " answer
    if [ ! "$answer" == "y" -a ! "$answer" == "yes" ]; then
      return 0
    else
      # backup just in case
      cp ~/.dirs ~/.dirs.bak
      # delete existing version(s) of this alias
      $(cat ~/.dirs | sed "s/^$@=.*//" | sed '/^$/d' > ~/.dirs)
    fi
  fi
  echo "$@"=\"`pwd`\" >> ~/.dirs
  source ~/.dirs
  echo "Directory shortcuts:" `showdirs`
}
source ~/.dirs  # Initialization for the above 'save' facility: source the .dirs file
setopt CDABLE_VARS # set the zsh option so that no '$' is required when using the above facility

# show dirs at login
echo "Directory shortcuts:" `showdirs`

######## misc ##########

# mkdir, cd into it
mkcd () {
  mkdir -p "$*"
  cd "$*"
}

# Trash files
function trash () {
  local path
  for path in "$@"; do
    # ignore any arguments
    if [[ "$path" = -* ]]; then :
    else
      local dst=${path##*/}
      # append the time if necessary
      while [ -e ~/.Trash/"$dst" ]; do
        dst="$dst "$(date +%H-%M-%S)
      done
      mv "$path" ~/.Trash/"$dst"
    fi
  done
}

function copypath () {
  echo -n $PWD | pbcopy
}
