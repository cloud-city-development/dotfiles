#echo "=> Loading `pwd`/prompt"
# Set this so screen will show the currently-running program

# export PS1="$COLOR_RED\$(rvm-prompt) $COLOR_GREEN\w $COLOR_YELLOW\$(type -P git &>/dev/null && { git branch 2>/dev/null | grep '^*' | colrm 1 2 | sed 's_\(.*\)_(\1)_'; })$COLOR_GREEN\$$COLOR_NC\n→ "
# export PS1="$COLOR_RED\$RUBY_VERSION\[\033[01;32m\]\u@\h\[\033[01;34m\] \w$COLOR_YELLOW\$(parse_git_branch)\$\[\033[00m\] "

# Prompts ----------------------------------------------------------
# export PS1="\[${COLOR_GREEN}\]\w > \[${COLOR_NC}\]"  # Primary prompt with only a path	
# export PS1="\[${COLOR_RED}\]\w > \[${COLOR_NC}\]"  # Primary prompt for root user, to highlight when you're logged in as root
# export PS1="\[${COLOR_GRAY}\]\u@\h \[${COLOR_GREEN}\]\w > \[${COLOR_NC}\]"  # Primary prompt with user, host, and path 

# This runs before the prompt and sets the title of the xterm* window.  If you set the title in the prompt
# weird wrapping errors occur on some systems, so this method is superior
# Turn this off of you are running directly in the console on the machine

#git command prompt http://effectif.com/git/config
if [[ -e ~/src/git/contrib/completion/git-completion.bash ]]; then
  . ~/src/git/contrib/completion/git-completion.bash
else
function __git_ps1() {
    local b="$(git symbolic-ref HEAD 2>/dev/null)";
    if [ -n "$b" ]; then
      printf "(%s)" "${b##refs/heads/}";
    fi
  }
fi

function parse_svn_repository_root() {
  if [ -d ".svn" ]; then
    svn info 2>/dev/null | sed -ne 's#^Repository Root: ##p'
  fi
}

function parse_svn_url() {
  if [ -d ".svn" ]; then
    svn info 2>/dev/null | sed -ne 's#^URL: ##p' | sed -e 's#^'"$(parse_svn_repository_root)"'##g' | egrep -o '(tags|branches)/[^/]+|trunk' | egrep -o '[^/]+$' | awk '{print $1}'
  fi
}

function parse_svn_revision() {
  if [ -d ".svn" ]; then
    svn info $(parse_svn_repository_root) | awk '/^Revision:/{print $2}'
  fi
}

function parse_svn_branch() {
  if [ -d ".svn" ]; then
    branch=`parse_svn_url | sed -e 's#^'"$(parse_svn_repository_root)"'##g' | awk '{print $1}'`
    if [ -n "${branch}" ]; then
      echo "$branch"
    else
      echo "none"
    fi
  fi
}

function parse_svn_revisions_behind() {
  # shows how many commits behind remote server
  echo $(parse_svn_revision) $(svnversion) | awk '{print $1 - int($2)}'
}

function parse_svn_dirty() {
  status=`svn status 2> /dev/null`
  modified=`  echo -n "${status}" 2> /dev/null | grep -q "M       " 2> /dev/null; echo "$?"`
  untracked=` echo -n "${status}" 2> /dev/null | grep -q "?       " 2> /dev/null; echo "$?"`
  newfile=`   echo -n "${status}" 2> /dev/null | grep -q "A       " 2> /dev/null; echo "$?"`
  conflict=`  echo -n "${status}" 2> /dev/null | grep -q "C       " 2> /dev/null; echo "$?"`
  prop_con=`  echo -n "${status}" 2> /dev/null | grep -q " C      " 2> /dev/null; echo "$?"`
  deleted=`   echo -n "${status}" 2> /dev/null | grep -q "D       " 2> /dev/null; echo "$?"`
  replaced=`  echo -n "${status}" 2> /dev/null | grep -q "R       " 2> /dev/null; echo "$?"`
  missing=`   echo -n "${status}" 2> /dev/null | grep -q "!       " 2> /dev/null; echo "$?"`
  rem_lock=`  echo -n "${status}" 2> /dev/null | grep -q "  L     " 2> /dev/null; echo "$?"`
  local_lock=`echo -n "${status}" 2> /dev/null | grep -q "     K  " 2> /dev/null; echo "$?"`
  lock_del=`  echo -n "${status}" 2> /dev/null | grep -q "D    K  " 2> /dev/null; echo "$?"`
  switch=`    echo -n "${status}" 2> /dev/null | grep -q "    S   " 2> /dev/null; echo "$?"`
  changed=`   echo -n "${status}" 2> /dev/null | grep -q "~       " 2> /dev/null; echo "$?"`
  bits=""
  if [ "${modified}" == "0" ]; then
          bits="${bits}☭"
  fi
  if [ "${untracked}" == "0" ]; then
          bits="${bits}⚡"
  fi
  if [ "${newfile}" == "0" ]; then
          bits="${bits}*"
  fi
  if [ "${conflict}" == "0" ]; then
          bits="${bits}<<"
  fi
  if [ "${prop_con}" == "0" ]; then
          bits="${bits}>>"
  fi
  if [ "${deleted}" == "0" ]; then
          bits="${bits}D"
  fi
  if [ "${replaced}" == "0" ]; then
          bits="${bits}%"
  fi
  if [ "${missing}" == "0" ]; then
          bits="${bits}?"
  fi
  if [ "${rem_lock}" == "0" ]; then
          bits="${bits}RL"
  fi
  if [ "${local_lock}" == "0" ]; then
          bits="${bits}L"
  fi
  if [ "${lock_del}" == "0" ]; then
          bits="${bits}ÐL"
  fi
  if [ "${bits}" != "" ]; then
          bits=":${bits}"
  fi
  echo "${bits}"
}

function parse_git_dirty() {
    status=`git status 2> /dev/null`
    dirty=`    echo -n "${status}" 2> /dev/null | grep -q "Changed but not updated" 2> /dev/null; echo "$?"`
    untracked=`echo -n "${status}" 2> /dev/null | grep -q "Untracked files" 2> /dev/null; echo "$?"`
    ahead=`    echo -n "${status}" 2> /dev/null | grep -q "Your branch is ahead of" 2> /dev/null; echo "$?"`
    newfile=`  echo -n "${status}" 2> /dev/null | grep -q "new file:" 2> /dev/null; echo "$?"`
    renamed=`  echo -n "${status}" 2> /dev/null | grep -q "renamed:" 2> /dev/null; echo "$?"`
    bits=''
    if [ "${dirty}" == "0" ]; then
          bits="${bits}☭"
    fi
    if [ "${untracked}" == "0" ]; then
          bits="${bits}?"
    fi
    if [ "${newfile}" == "0" ]; then
          bits="${bits}*"
    fi
    if [ "${ahead}" == "0" ]; then
          bits="${bits}+"
    fi
    if [ "${renamed}" == "0" ]; then
          bits="${bits}>"
    fi
    echo "${bits}"
}

function parse_git_svn_revision() {
    ref1=$(__git_ps1 | sed -e "s/ (\(.*\))/(git:\1$(parse_git_dirty))/")
    #ref1=$(parse_git_branch)

    if [ "x$ref1" != "x"  ]; then
      ref2=$(git branch -a | grep git-svn)
      if [ "x$ref2" != "x" ]; then
          ref3=$(git svn info | grep Revision)
          echo " ${ref1}(svn:r"${ref3#Revision: }")"
      else
          echo " ${ref1} "
      fi
    elif [ "`svnversion`" != "exported"  ];then 
      echo "(svn:`parse_svn_branch``parse_svn_dirty`)"
    fi
}

function parse_git_branch() {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/(\1$(parse_git_dirty))/"
}

export PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*} [$(rvm-prompt)] ${PWD}"; echo -ne "\007"'  # user@host path
#\$(__git_ps1 \"(%s)\")\$(parse_svn_branch)
export PS1="$COLOR_BROWN${USER}$COLOR_RED[\$(rvm-prompt)]$COLOR_GREEN\w$COLOR_RED\$(parse_git_svn_revision)$COLOR_GREEN\$$COLOR_NC\n→ "
export PS2='>'   # Secondary prompt
export PS3='?'   # Prompt 3
export PS4='+'   # Prompt 4

function xtitle {  # change the title of your xterm* window
  unset PROMPT_COMMAND
  echo -ne "\033]0;$1\007"
}

# Hello Messsage --------------------------------------------------
# echo -e "Kernel Information: " `uname -smr`
# echo -e "${COLOR_BROWN}`bash --version`"
# echo -ne "${COLOR_GRAY}Uptime: "; uptime
# echo -ne "${COLOR_GRAY}Server time is: "; date
# 
